<script type="module">
  // Create a Vue app
  const app = Vue.createApp({
    data() {
      return {
        fullscreenTarget: null,
        questions: [],
        loading: true,
        url_top: null,
        user: {},
        form: {},
        results: {},
        dayOfWeekJp: ["Êó•", "Êúà", "ÁÅ´", "Ê∞¥", "Êú®", "Èáë", "Âúü"],
        validates: {},
        invalidEmail: false,
        invalidLocation: false,
        dimensionAllow: 0,
        vote: null,
        settings: {},
        surveySetting: {},
        location: null,
        disabledClick: false,
        isDescription: "text-description",
        showModal: false,
        ipAddress: null,
        currentQuestionIndex: 0,
        passcode: "",
        checkPasscode: false,
        validatePasscode: true,
        isOutOfDate: false,
        isNGCheck: null,
        checkStatus: true,
        msgStatus: null,
        identified: false,
        quesVisit: 0,
        cssDoQuestFooter: {
          bottom: "10px",
          // left: '20px',
          // right: '20px'
        },
        msgOutDate: "",
        emailUser: null,
        isShowPW: false,
        passcodeIncorrect: false,
        showUserInfo: false,
        isPreview: false,
        isBacked: false,
        colorClasses: [
          "bg-success",
          "bg-info",
          "bg-warning",
          "bg-danger",
          "bg-primary",
        ],
        colors: {},
        // transient holder for validation context
        lastValidation: null,
      };
    },
    created() {},
    watch: {},
    async mounted() {
      for (let key in this.questions) {
        console.log(key, this.questions[key]);
      }

      document.getElementById("loading").style.display = "block";
      document.addEventListener("click", this.handleClickOutside);
      this.emailUser = login ? login.email : "";
      this.url_top = await this.getUrlTop();
      this.settings = this.getDataSetting();
      await this.getQuestions(surveyID);
      await this.dataStatistics(surveyID);

      this.debugData();

      this.ipAddress = await this.getIPAddress();
      this.isNGCheck = await this.checkNG();
      setTimeout(() => {
        if (!this.checkPasscode) {
          $("#passcodeModal").modal({
            backdrop: "static",
            keyboard: false,
          });
          $("#passcodeModal").modal("show");
        }
        // this.updateElementHeights();
        // window.addEventListener('resize', this.updateElementHeights);
      }, 500);
      this.ensureFormStructure();
    },
    computed: {},
    methods: {
      // Determine top answer for questions WITHOUT criteria
      getTopNoCriteria(questionResult) {
        if (!questionResult || !questionResult.question_answers) return null;
        const arr = this.getAnswersArray(questionResult);
        if (!arr.length) return null;
        let max = -1;
        let topName = null;
        let countMax = 0;
        arr.forEach((a) => {
          const v = Number(a.total || 0);
          if (v > max) {
            max = v;
            topName = a.name || a.answer || a.label || a.title || null;
            countMax = 1;
          } else if (v === max) {
            countMax += 1;
          }
        });
        // No top when all zero or tie
        if (max <= 0 || countMax !== 1) return null;
        return topName;
      },

      // Determine top answer name for a given criteria
      getTopByCriteria(questionResult, criteriaName) {
        if (!questionResult || !questionResult.question_answers) return null;
        const arr = this.getAnswersArray(questionResult);
        if (!arr.length) return null;
        let max = -1;
        let topName = null;
        let countMax = 0;
        arr.forEach((a) => {
          const v = Number((a.criteria && a.criteria[criteriaName]) || 0);
          if (v > max) {
            max = v;
            topName = a.name || a.answer || a.label || a.title || null;
            countMax = 1;
          } else if (v === max) {
            countMax += 1;
          }
        });
        if (max <= 0 || countMax !== 1) return null;
        return topName;
      },
      getAnswersArray(questionResult) {
        if (!questionResult || !questionResult.question_answers) return [];
        return Array.isArray(questionResult.question_answers)
          ? questionResult.question_answers
          : Object.values(questionResult.question_answers);
      },

      getTotalAnswers(questionResult) {
        const arr = this.getAnswersArray(questionResult);
        return arr.reduce((sum, a) => sum + Number(a.total || 0), 0);
      },

      // Method m·ªõi ƒë·ªÉ t√¨m answer result theo name
      getResultAnswer(answerName) {
        if (
          !this.results[this.currentQuestionIndex] ||
          !this.results[this.currentQuestionIndex].question_answers
        ) {
          return { total: 0 };
        }

        const answers = this.getAnswersArray(
          this.results[this.currentQuestionIndex]
        );
        const found = answers.find((a) => a.name === answerName);
        return found || { total: 0 };
      },

      getPercentageNoCriteria(ans, questionResult) {
        if (!ans || !questionResult) return 0;

        const arr = this.getAnswersArray(questionResult);
        const total = arr.reduce((sum, a) => sum + Number(a.total || 0), 0);
        return total > 0 ? (Number(ans.total || 0) / total) * 100 : 0;
      },

      // Debug method ƒë·ªÉ ki·ªÉm tra data
      debugData() {
        console.log("Current Question Index:", this.currentQuestionIndex);
        console.log(
          "Item question_answers:",
          this.questions[this.currentQuestionIndex]?.question_answers
        );
        console.log(
          "Results question_answers:",
          this.results[this.currentQuestionIndex]?.question_answers
        );
        console.log("Full results:", this.results[this.currentQuestionIndex]);
      },
      getWinner(questionResult, crit) {
        if (!questionResult) return { name: "-" };

        const qa = questionResult.question_answers;

        // Chuy·ªÉn v·ªÅ m·∫£ng an to√†n:
        let answers = [];
        if (Array.isArray(qa)) {
          answers = qa;
        } else if (qa && typeof qa === "object") {
          // N·∫øu mu·ªën gi·ªØ id/key, d√πng Object.keys -> map; n·∫øu kh√¥ng c·∫ßn id th√¨ d√πng Object.values
          answers = Object.keys(qa).map((key) => {
            // n·∫øu gi√° tr·ªã ƒë√£ c√≥ answer/label... gi·ªØ nguy√™n, b·ªï sung id
            return Object.assign({ id: key }, qa[key]);
          });
          // ho·∫∑c: answers = Object.values(qa);
        } else {
          // unexpected type
          console.warn("getWinner: unexpected question_answers type", qa);
          return { name: "-" };
        }

        // T√¨m answer c√≥ s·ªë vote l·ªõn nh·∫•t (an to√†n v·ªõi tr∆∞·ªùng h·ª£p thi·∫øu fields)
        let maxAns = null;
        let maxVotes = -Infinity;
        answers.forEach((ans) => {
          const votes =
            crit && ans.criteria
              ? ans.criteria[crit.name] || 0
              : ans.total || 0 || 0;
          if (typeof votes === "number" && votes > maxVotes) {
            maxVotes = votes;
            maxAns = ans;
          }
        });

        // L·∫•y t√™n hi·ªÉn th·ªã: ∆∞u ti√™n c√°c field th∆∞·ªùng th·∫•y
        const name = maxAns
          ? maxAns.answer || maxAns.label || maxAns.name || maxAns.title || "-"
          : "-";
        return { name };
      },
      convertDriveLink(originalLink) {
        if (!originalLink) return "";

        // √©p v·ªÅ string ƒë·ªÉ ch·∫Øc ch·∫Øn .match() kh√¥ng l·ªói
        const link = String(originalLink);

        // Ki·ªÉm tra n·∫øu l√† link ·∫£nh tr·ª±c ti·∫øp
        if (/\.(jpg|jpeg|png|gif|webp|bmp|svg)$/i.test(link)) {
          return link; // gi·ªØ nguy√™n
        }

        // Ki·ªÉm tra n·∫øu l√† link Google Drive d·∫°ng /d/xxx/
        const fileIdMatch = link.match(/\/d\/(.*?)\//);
        if (fileIdMatch && fileIdMatch[1]) {
          const fileId = fileIdMatch[1];
          return "https://drive.google.com/file/d/" + fileId + "/preview";
        }

        // N·∫øu kh√¥ng thu·ªôc d·∫°ng n√†o th√¨ tr·∫£ v·ªÅ link g·ªëc
        return link;
      },
      // ƒê·ªìng b·ªô logic v·ªõi voteRegisterJS: nh·∫≠n di·ªán c·∫£ link file ·∫£nh & chu·ªói base64 data URI
      isImage(url) {
        if (!url) return false;
        const link = String(url).trim();
        // T√°ch b·ªè query/hash ƒë·ªÉ ki·ªÉm tra ph·∫ßn ƒëu√¥i file chu·∫©n
        const pure = link.split("?")[0].split("#")[0];

        // 1. ƒêu√¥i ·∫£nh chu·∫©n (h·ªó tr·ª£ c√≥ query ph√≠a sau)
        if (/\.(jpg|jpeg|png|gif|webp|bmp|svg)$/i.test(pure)) return true;

        // 1b. Googleusercontent: kh√¥ng c√≥ ƒëu√¥i nh∆∞ng l√† ·∫£nh
        if (/https?:\/\/lh\d+\.googleusercontent\.com\//i.test(link))
          return true;

        // 2. data URI base64
        if (/^data:image\//i.test(link)) return true;

        // 3. Bing thumbnail (kh√¥ng c√≥ extension nh∆∞ng pattern OIP.*)
        //    V√≠ d·ª•: https://tse4.mm.bing.net/th/id/OIP.XXXX?pid=Api&P=0&h=220
        // Bing thumbnail: OIP.* (ch·ªØ hoa/th∆∞·ªùng, nhi·ªÅu k√Ω t·ª±)
        if (
          /https?:\/\/tse\d+\.mm\.bing\.net\/th\/id\/OIP\.[A-Za-z0-9_-]+/i.test(
            link
          )
        )
          return true;

        // 4. ftcdn pattern (ƒë√¥i khi c√≥ nhi·ªÅu segment, ƒë·∫£m b·∫£o ch·ª©a /v2/jpg/)
        if (/https?:\/\/[^/]*ftcdn\.net\/v2\/jpg\//i.test(link)) return true;

        return false;
      },
      isCriteriaEmpty(ans) {
        return ans == null || ans.criteria === "" || ans.criteria == null;
      },

      // Tr·∫£ total an to√†n (number)
      safeTotal(item1, critName) {
        if (!item1 || !item1.total) {
          console.log(
            "safeTotal for crit:",
            critName,
            "= 0 (item1 invalid)",
            item1
          );
          return 0;
        }
        const v = item1.total[critName];
        const total = Number(v) || 0;

        console.log(
          "safeTotal for crit:",
          critName,
          "=",
          total,
          "from item1.total:",
          item1.total
        );

        return total;
      },

      // T√≠nh % an to√†n. decimals m·∫∑c ƒë·ªãnh 1 (v√≠ d·ª• 12.3)
      safeCalculatePercentage(numerator, denominator, decimals = 1) {
        const num = Number(numerator) || 0;
        const den = Number(denominator) || 0;
        if (den === 0) return 0;
        return Number(((num / den) * 100).toFixed(decimals));
      },

      // L·∫•y % ƒë·ªÉ binding width / aria-valuenow ‚Äî d√πng logic: n·∫øu ans.criteria r·ªóng -> ans.total, ng∆∞·ª£c l·∫°i -> ans.criteria[crit.name]
      getPercentageFor(ans, item1, crit) {
        const total = this.safeTotal(item1, crit.name);
        let num = 0;
        if (this.isCriteriaEmpty(ans)) {
          num = Number(ans && ans.total) || 0;
        } else {
          // n·∫øu ans.criteria t·ªìn t·∫°i nh∆∞ng kh√¥ng c√≥ crit.name -> fallback 0
          num = Number(ans.criteria && ans.criteria[crit.name]) || 0;
        }
        return total > 0 ? Math.round((num / total) * 100) : 0;
      },

      // L·∫•y m√†u an to√†n (fallback '#ffffff')
      getColor(item, idx) {
        if (!item || !item.colors || !this.colors) return "#ffffff";
        const key = item.colors[idx];
        return key && this.colors[key] ? this.colors[key] : "#ffffff";
      },

      // G·ªçi khi component load ho·∫∑c ngay sau khi 'items' / 'form' / 'criterias' ƒë∆∞·ª£c load t·ª´ API
      ensureFormStructure() {
        (this.items || []).forEach((it, i) => {
          const key = `${i + 1}Ôºé${it.question}`;

          // N·∫øu form[key] ch∆∞a t·ªìn t·∫°i ‚Üí t·∫°o m·ªõi
          if (!this.form[key]) {
            if (this.$set) {
              this.$set(this.form, key, {
                criterias: {}, // cho tr∆∞·ªùng h·ª£p ƒëa ti√™u ch√≠
                value: it.question_type === "multiSelect" ? [] : "", // cho tr∆∞·ªùng h·ª£p kh√¥ng ƒëa ti√™u ch√≠
              });
            } else {
              this.form[key] = {
                criterias: {},
                value: it.question_type === "multiSelect" ? [] : "",
              };
            }
          }

          // N·∫øu c√≥ ti√™u ch√≠ ‚Üí kh·ªüi t·∫°o s·∫µn
          (it.criterias || []).forEach((crit) => {
            if (!this.form[key].criterias[crit.name]) {
              const defaultValue = it.question_type === "multiSelect" ? [] : "";
              if (this.$set) {
                this.$set(this.form[key].criterias, crit.name, {
                  value: defaultValue,
                });
              } else {
                this.form[key].criterias[crit.name] = { value: defaultValue };
              }
            }
          });
        });
      },
      calculatePercentage(value, total) {
        if (total == 0 || total == undefined) {
          return 0; // Tr√°nh chia cho 0
        }
        return Math.floor((value / total) * 100); // L√†m tr√≤n xu·ªëng v√† tr·∫£ v·ªÅ s·ªë nguy√™n
      },
      async reloadPage() {
        await this.dataStatistics(surveyID);
      },
      getProgressBarClass(idx) {
        // L·∫•y m√†u t·ª´ m·∫£ng, s·ª≠ d·ª•ng to√°n t·ª≠ % ƒë·ªÉ l·∫∑p l·∫°i khi idx v∆∞·ª£t qu√° 4
        return this.colorClasses[idx % this.colorClasses.length];
      },
      getInitial() {
        return this.user.email.charAt(0).toUpperCase();
      },
      toggleUserInfo(event) {
        event.stopPropagation();
        this.showUserInfo = !this.showUserInfo;
      },
      handleClickOutside(event) {
        const userInfo = document.getElementById("user-info");
        const userAvatar = document.getElementById("user-avatar");
        if (
          userInfo &&
          userAvatar &&
          !userAvatar.contains(event.target) &&
          !userInfo.contains(event.target)
        ) {
          this.showUserInfo = false;
        }
      },
      getUrlTop() {
        let scope = this;
        return new Promise((resolve, reject) => {
          google.script.run
            .withSuccessHandler((res) => {
              resolve(res);
            })
            .withFailureHandler((error) => {
              reject(error);
            })
            .getUrlTop();
        });
      },
      getDataSetting() {
        let scope = this;
        return new Promise((resolve, reject) => {
          google.script.run
            .withSuccessHandler((res) => {
              resolve(res);
            })
            .withFailureHandler((error) => {
              reject(error);
            })
            .getDataSetting();
        });
      },
      checkNG() {
        let check = true;
        if (this.questions.length == 0) {
          check = false;
        }
        if (this.isOutOfDate) {
          check = false;
        }
        if (this.vote.status == "ÁµÇ‰∫ÜÊ∏à") {
          check = false;
          this.msgStatus =
            "„Åì„ÅÆÊäïÁ•®„ÅåÁµÇ‰∫Ü„Åó„Åæ„Åó„Åü„ÅÆ„Åß„ÄÅÊäïÁ•®„ÇíË°å„ÅÜ„Åì„Å®„ÅØ„Åß„Åç„Åæ„Åõ„Çì„ÄÇ";
        }
        if (this.vote.status == "‰ΩúÊàê‰∏≠") {
          check = false;
          this.msgStatus =
            "„Åì„ÅÆÊäïÁ•®„Åå‰ΩúÊàê‰∏≠„Åß„Åô„ÅÆ„Åß„ÄÅÊäïÁ•®„ÇíË°å„ÅÜ„Åì„Å®„ÅØ„Åß„Åç„Åæ„Åõ„Çì„ÄÇ";
        }
        if (this.vote.status == "ÈùûÂÖ¨Èñã") {
          check = false;
          this.msgStatus =
            "„Åì„ÅÆÊäïÁ•®„ÅåÈùûÂÖ¨Èñã„Åß„Åô„ÅÆ„Åß„ÄÅÊäïÁ•®„ÇíË°å„ÅÜ„Åì„Å®„ÅØ„Åß„Åç„Åæ„Åõ„Çì„ÄÇ";
        }
        document.getElementById("loading").style.display = "";
        return check;
      },
      checkPasscodeVote() {
        // Validate
        if (this.passcode == "") {
          this.validatePasscode = false;
          this.passcodeIncorrect = false;
          this.checkPasscode = false;
          return;
        } else {
          this.validatePasscode = true;
          if (this.passcode == this.vote.passcode) {
            this.checkPasscode = true;
            $("#passcodeModal").modal("hide");
            this.initialDatepicker();
            this.isAnswered();
          } else {
            this.passcodeIncorrect = true;
          }
        }
      },
      openModalInfomation() {
        // $('#userInformation').modal({
        //     backdrop: 'static',
        //     keyboard: false
        // });
        $("#userInformation").modal("show");
      },
      toGlobalDate(date) {
        return date.replace("Âπ¥", "/").replace("Êúà", "/").replace("Êó•", "");
      },
      checkDate(startDate, endDate) {
        if (!startDate && !endDate) return false;
        let scope = this;
        let now = new Date();
        let res = {
          isOutOfDate: false,
          msgOutDate: "",
        };

        let startVal = !startDate
          ? now
          : new Date(scope.toGlobalDate(startDate));
        let endVal = !endDate ? now : new Date(scope.toGlobalDate(endDate));
        if (now - endVal > 0) {
          res.isOutOfDate = true;
          res.msgOutDate =
            "ÊäïÁ•®„ÇíÂèó„Åë„ÇãÊôÇÈñì„ÅØ„ÇÇ„ÅÜÈÅé„Åé„Åæ„Åó„Åü„ÅÆ„Åß„ÄÅÊäïÁ•®„ÇíË°å„ÅÜ„Åì„Å®„ÅØ„Åß„Åç„Åæ„Åõ„Çì„ÄÇ";
        } else if (startVal - now > 0) {
          res.isOutOfDate = true;
          res.msgOutDate =
            "„Åæ„Å†ÊäïÁ•®„ÇíÂèó„Åë„ÇãÊôÇÈñì„Åß„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì„ÅÆ„Åß„ÄÅÊäïÁ•®„ÇíË°å„ÅÜ„Åì„Å®„ÅØ„Åß„Åç„Åæ„Åõ„Çì„ÄÇ";
        } else {
          res.isOutOfDate = false;
          res.msgOutDate = "";
        }
        return res;
      },
      getQuestions(surveyID) {
        let scope = this;
        return new Promise((resolve, reject) => {
          let scope = this;
          google.script.run
            .withSuccessHandler((res) => {
              if (!res) {
                scope.failureHandler(res.msg);
                reject("Failed to get questions");
                return;
              }
              let { keys, rows, surveySetting, vote } = res.data;
              // this.data.colors = res.colors;
              // G√°n gi√° tr·ªã res.colors v√†o this.colors
              this.colors = res.colors;
              scope.surveySetting = surveySetting;
              scope.vote = vote;
              vote.display_type = vote.displayType;
              vote.displayType =
                vote.displayType == "Ôºë„Éö„Éº„Ç∏„ÅßÂÖ®„Å¶Ë°®Á§∫" ? "all" : "one";
              if (this.vote.usePassCode == "„ÅÑ„ÅÑ„Åà") {
                this.checkPasscode = true;
              }
              let { isOutOfDate, msgOutDate } = scope.checkDate(
                this.vote.dateRun,
                this.vote.dateEnd
              );
              scope.formatData(keys, rows);
              scope.isOutOfDate = isOutOfDate;
              scope.msgOutDate = msgOutDate;
              resolve(); // resolve the promise when everything is done
            })
            .getQuestions(surveyID);
        });
      },

      dataStatistics(surveyID) {
        let scope = this;
        document.getElementById("loading").style.display = "block";

        return new Promise((resolve, reject) => {
          google.script.run
            .withSuccessHandler((res) => {
              if (!res) {
                document.getElementById("loading").style.display = "none";
                scope.failureHandler("No data from server");
                reject(new Error("No data"));
                return;
              }

              // Lu√¥n gi·ªØ ƒë√∫ng index, thay null/undefined b·∫±ng object tr·ªëng
              const rawData = res.data;
              let normalizedArray = [];

              if (Array.isArray(rawData)) {
                normalizedArray = rawData;
              } else if (rawData && typeof rawData === "object") {
                normalizedArray = Object.values(rawData); // üëà bi·∫øn object c√≥ key s·ªë th√†nh array
              }

              this.results = normalizedArray.map(
                (q) =>
                  q || {
                    total: {},
                    maxChoices: {},
                    question_answers: {},
                  }
              );

              const qList = Array.isArray(this.questions) ? this.questions : [];

              this.results.forEach((question, qIndex) => {
                const questionAnswers = question.question_answers || {};
                const answersArray = Object.values(questionAnswers);
                const max =
                  qList[qIndex] && qList[qIndex].max !== undefined
                    ? qList[qIndex].max
                    : 1;
                const min =
                  qList[qIndex] && qList[qIndex].min !== undefined
                    ? qList[qIndex].min
                    : 0;

                let totals = {};
                let maxChoices = {};

                // üîπ T√≠nh totals
                answersArray.forEach((answer) => {
                  if (
                    !answer ||
                    answer.criteria == undefined ||
                    answer.criteria === ""
                  ) {
                    if (!totals["ÊäïÁ•®ÁµêÊûú"]) totals["ÊäïÁ•®ÁµêÊûú"] = 0;
                    totals["ÊäïÁ•®ÁµêÊûú"] += Number(answer && answer.total) || 0;
                    if (answer) answer.criteria = "";
                  } else {
                    Object.keys(answer.criteria).forEach((key) => {
                      if (!totals[key]) totals[key] = 0;
                      totals[key] += Number(answer.criteria[key]) || 0;
                    });
                  }
                });

                // üîπ Chu·∫©n b·ªã keyValueArray / keyArray
                let keyValueArray = [];
                let keyArray = [];
                let i = 0;
                answersArray.forEach((answer) => {
                  if (!answer || answer.criteria === "") {
                    if (!keyValueArray[i]) {
                      keyValueArray[i] = [];
                      keyArray.push("ÊäïÁ•®ÁµêÊûú");
                    }
                    keyValueArray[i].push({
                      key: Number(answer && answer.total) || 0,
                      value: answer && answer.name ? answer.name : "",
                    });
                  } else {
                    let j = 0;
                    Object.keys(answer.criteria).forEach((key) => {
                      if (i === 0) {
                        keyValueArray[j] = keyValueArray[j] || [];
                        keyArray.push(key);
                      }
                      keyValueArray[j].push({
                        key: Number(answer.criteria[key]) || 0,
                        value: answer && answer.name ? answer.name : "",
                      });
                      j++;
                    });
                    i++;
                  }
                });

                // üîπ Ch·ªçn maxChoices
                let resultArray = [];
                let num1 = 0;
                keyValueArray.forEach((array) => {
                  if (!array || array.length === 0) {
                    resultArray.push("");
                    num1++;
                    return;
                  }

                  let sortedArray = [...array].sort((a, b) => b.key - a.key);
                  let selectedElements = [];
                  let count = 0;
                  let currentKey = sortedArray[0].key;
                  let keyPosition = keyArray[num1];
                  const totalForKey =
                    totals && totals[keyPosition] ? totals[keyPosition] : 0;

                  if (
                    totalForKey > 0 &&
                    Math.floor((currentKey / totalForKey) * 100) >= min
                  ) {
                    sortedArray.forEach((item) => {
                      if (item.key === currentKey) {
                        selectedElements.push(item.value);
                        count++;
                      }
                    });

                    if (count < max) {
                      const nextKeyObj = sortedArray.find(
                        (item) => item.key < currentKey
                      );
                      if (nextKeyObj) {
                        const nextKey = nextKeyObj.key;
                        if (Math.floor((nextKey / totalForKey) * 100) >= min) {
                          sortedArray.forEach((item) => {
                            if (item.key === nextKey) {
                              selectedElements.push(item.value);
                              count++;
                            }
                          });
                        }
                      }
                    }
                  }

                  resultArray.push(selectedElements.join(", "));
                  num1++;
                });

                // üîπ g√°n maxChoices t∆∞∆°ng ·ª©ng
                let idx = 0;
                Object.keys(totals).forEach((key) => {
                  maxChoices[key] = resultArray[idx] || "";
                  idx++;
                });

                // üîπ G√°n v√†o t·ª´ng question
                this.results[qIndex].total = totals;
                this.results[qIndex].maxChoices = maxChoices;
              });

              console.log("üëâ Processed results:", this.results);

              document.getElementById("loading").style.display = "none";
              resolve(this.results);
            })
            .withFailureHandler((error) => {
              document.getElementById("loading").style.display = "none";
              console.error(error);
              scope.failureHandler(error);
              reject(error);
            })
            .dataStatistics(surveyID);
        });
      },
      formatData(keys, rows) {
        var i = 0;
        this.questions = [];
        let linkRegex = /<([^>]+)>/;

        let storage = localStorage.getItem(surveyID)
          ? JSON.parse(localStorage.getItem(surveyID))
          : null;
        let user = localStorage.getItem("user")
          ? JSON.parse(localStorage.getItem("user"))
          : null;

        if (storage && user) {
          this.user.address = user.address ? user.address : "";
          this.user.phone_number = user.phone_number ? user.phone_number : "";
          this.user.email = user.email ? user.email : "";
          this.user.name = user.name ? user.name : "";
        } else {
          this.user.address = "";
          this.user.phone_number = "";
          this.user.email = "";
          this.user.name = "";
        }

        if (this.vote.informationRequired == "„ÅÇ„Çä") {
          this.validates = {
            email: true,
            name: true,
          };
        } else {
          this.validates = {};
        }

        for (let i = 0; i < rows.length; i++) {
          let obj = {};
          for (const [k, v] of Object.entries(keys)) {
            if (v === -1) continue;
            obj[k] = rows[i][v];

            if (k === "question") {
              this.form[`${i + 1}Ôºé${rows[i][v]}`] = {
                type: rows[i][keys.question_type],
              };

              // ==== X·ª≠ l√Ω ti√™u ch√≠ (criterias) ====
              if (rows[i][keys.criterias].length > 0) {
                for (let key = 0; key < rows[i][keys.criterias].length; key++) {
                  let text = rows[i][keys.criterias][key];
                  let match = text.match(linkRegex);

                  if (match) {
                    rows[i][keys.criterias][key] = {
                      name: text.replace(match[0], ""),
                    };
                    let url = match[1];

                    if (/\.(jpg|jpeg|png|gif|webp|bmp|svg)$/i.test(url)) {
                      rows[i][keys.criterias][key]["media"] = url; // ·∫£nh ngo√†i
                    } else if (url.includes("/d/")) {
                      // link Google Drive
                      let startIndex = url.indexOf("/d/");
                      let endIndex = url.indexOf("/", startIndex + 3);
                      if (endIndex === -1) endIndex = url.length;
                      let link =
                        "https://drive.google.com/file/d/" +
                        url.substring(startIndex + 3, endIndex) +
                        "/preview";
                      rows[i][keys.criterias][key]["media"] = link;
                    } else {
                      rows[i][keys.criterias][key]["media"] = url; // fallback
                    }
                  } else {
                    rows[i][keys.criterias][key] = { name: text, media: false };
                  }
                }

                this.form[`${i + 1}Ôºé${rows[i][v]}`].criteria = true;
                this.form[`${i + 1}Ôºé${rows[i][v]}`]["criterias"] = {};

                for (let key = 0; key < rows[i][keys.criterias].length; key++) {
                  this.form[`${i + 1}Ôºé${rows[i][v]}`]["criterias"][
                    `${rows[i][keys.criterias][key]["name"]}`
                  ] = {};
                  if (rows[i][keys.question_type] === "multiSelect") {
                    this.form[`${i + 1}Ôºé${rows[i][v]}`]["criterias"][
                      `${rows[i][keys.criterias][key]["name"]}`
                    ]["value"] = [];
                  } else {
                    this.form[`${i + 1}Ôºé${rows[i][v]}`]["criterias"][
                      `${rows[i][keys.criterias][key]["name"]}`
                    ]["value"] = "";
                  }
                }
              } else {
                this.form[`${i + 1}Ôºé${rows[i][v]}`].criteria = false;
                if (rows[i][keys.question_type] === "multiSelect") {
                  this.form[`${i + 1}Ôºé${rows[i][v]}`]["value"] = [];
                } else {
                  this.form[`${i + 1}Ôºé${rows[i][v]}`]["value"] = "";
                }
              }

              if (rows[i][keys.question_hasNote])
                this.form[`${i + 1}Ôºé${rows[i][v]}`]["note"] = "";

              // ==== X·ª≠ l√Ω c√¢u tr·∫£ l·ªùi (answers) ====
              if (rows[i][keys.question_answers].length > 0) {
                for (
                  let key = 0;
                  key < rows[i][keys.question_answers].length;
                  key++
                ) {
                  let text = rows[i][keys.question_answers][key];
                  let match = text.match(linkRegex);

                  if (match) {
                    rows[i][keys.question_answers][key] = {
                      name: text.replace(match[0], ""),
                    };
                    let url = match[1];

                    if (/\.(jpg|jpeg|png|gif|webp|bmp|svg)$/i.test(url)) {
                      rows[i][keys.question_answers][key]["media"] = url;
                    } else if (url.includes("/d/")) {
                      let startIndex = url.indexOf("/d/");
                      let endIndex = url.indexOf("/", startIndex + 3);
                      if (endIndex === -1) endIndex = url.length;
                      let link =
                        "https://drive.google.com/file/d/" +
                        url.substring(startIndex + 3, endIndex) +
                        "/preview";
                      rows[i][keys.question_answers][key]["media"] = link;
                    } else {
                      rows[i][keys.question_answers][key]["media"] = url;
                    }
                  } else {
                    rows[i][keys.question_answers][key] = {
                      name: text,
                      media: false,
                    };
                  }
                }
              }
            }
          }
          this.questions.push(obj);
        }
      },

      async startVote() {
        // Validate
        let check = true;
        for (const [k, v] of Object.entries(this.validates)) {
          if (this.user[k] == "" || !this.user[k]) {
            this.validates[k] = false;
            check = false;
          } else {
            this.validates[k] = true;
            if (k == "email") {
              let regex = /^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$/;
              let match = regex.exec(this.user[k]);
              if (!match) {
                this.validates[k] = false;
                check = false;
              } else {
                this.validates[k] = true;
              }
            }
            if (k == "phone_number") {
              let regex = /^\d{10,15}$/;
              let match = regex.exec(this.user[k]);
              if (!match) {
                this.validates[k] = false;
                check = false;
              } else {
                this.validates[k] = true;
              }
            }
          }
        }
        if (!check) return;

        // When name/email is required, check if this email already voted for this survey
        // If so, show a confirmation dialog before proceeding
        const proceed = await this.checkDuplicateEmailBeforeStart();
        if (!proceed) {
          // stay on current modal, do not continue
          return;
        }
        $("#userInformation").modal("hide");
        this.identified = true;
        this.$nextTick(() => {
          setTimeout(() => {
            this.updateElementHeights();
          }, 100); // ƒê·ª£i 100ms tr∆∞·ªõc khi g·ªçi h√†m
        });
        window.addEventListener("resize", () => {
          setTimeout(() => {
            this.updateElementHeights();
          }, 100);
        });
      },
      // Check if entered email has already been used for this survey; if yes, ask user to confirm
      checkDuplicateEmailBeforeStart() {
        return new Promise((resolve) => {
          try {
            const isInfoRequired =
              this.vote && this.vote.informationRequired === "„ÅÇ„Çä";
            const currentEmail = (
              this.user && this.user.email ? String(this.user.email) : ""
            )
              .trim()
              .toLowerCase();
            if (!isInfoRequired || !currentEmail) {
              resolve(true);
              return;
            }

            const hasVotedThisSurvey = !!localStorage.getItem(surveyID);
            const storedUserRaw = localStorage.getItem("user");
            const storedEmail = storedUserRaw
              ? JSON.parse(storedUserRaw).email || ""
              : "";
            const sameEmail =
              storedEmail &&
              String(storedEmail).trim().toLowerCase() === currentEmail;

            if (hasVotedThisSurvey && sameEmail) {
              Swal.fire({
                // Reuse Japanese confirmation style already used elsewhere
                text: "„Åì„ÅÆ„É°„Éº„É´„Ç¢„Éâ„É¨„Çπ„ÅØ‰ª•Ââç„Åì„ÅÆÊäïÁ•®„Åß‰ΩøÁî®„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ„ÇÇ„ÅÜ‰∏ÄÂ∫¶ÊäïÁ•®„Åó„Åæ„Åô„ÅãÔºü",
                icon: "question",
                showCancelButton: true,
                confirmButtonColor: "#01932e",
                cancelButtonColor: "#6A6A6A",
                confirmButtonText: "„ÅØ„ÅÑ",
                cancelButtonText: "„ÅÑ„ÅÑ„Åà",
                reverseButtons: true,
              }).then((result) => {
                resolve(result.isConfirmed === true);
              });
            } else {
              resolve(true);
            }
          } catch (e) {
            // In case of any parsing/storage errors, do not block user
            resolve(true);
          }
        });
      },
      validate(submitData) {
        let status = true;
        for (let i = 0; i < this.questions.length; i++) {
          const q = this.questions[i];
          const questionKey = `${i + 1}Ôºé${q.question}`;
          const formNow = submitData[questionKey];

          // default state
          this.validates[questionKey] = true;

          // 1) required empty check (applies to all types)
          if (q.question_required) {
            if (
              formNow &&
              formNow.criterias &&
              Object.keys(formNow.criterias).length > 0
            ) {
              for (const [, critValue] of Object.entries(formNow.criterias)) {
                const v = critValue && critValue.value;
                if (
                  v === "" ||
                  v == null ||
                  (Array.isArray(v) && v.length === 0)
                ) {
                  this.validates[questionKey] = "empty";
                  status = false;
                  break;
                }
              }
            } else {
              const v = formNow ? formNow.value : null;
              if (
                v === "" ||
                v == null ||
                (Array.isArray(v) && v.length === 0)
              ) {
                this.validates[questionKey] = "empty";
                status = false;
              }
            }
          }

          // 2) min/max check for multiSelect
          if (q.question_type === "multiSelect") {
            const min = Number(q.min ?? 0);
            const max = Number(q.max ?? 0);

            if (
              formNow &&
              formNow.criterias &&
              Object.keys(formNow.criterias).length > 0
            ) {
              // per criteria validation
              for (const [, critValue] of Object.entries(formNow.criterias)) {
                const arr = Array.isArray(critValue && critValue.value)
                  ? critValue.value
                  : [];
                if (min && arr.length < min) {
                  this.validates[questionKey] = "min";
                  status = false;
                  break;
                }
                if (max && arr.length > max) {
                  this.validates[questionKey] = "max";
                  status = false;
                  break;
                }
              }
            } else {
              const arr = Array.isArray(formNow && formNow.value)
                ? formNow.value
                : [];
              if (min && arr.length < min) {
                this.validates[questionKey] = "min";
                status = false;
              } else if (max && arr.length > max) {
                this.validates[questionKey] = "max";
                status = false;
              }
            }
          }
        }
        return status;
      },
      validationEmail(value) {
        const regex = /^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$/;
        const match = regex.exec(value);
        if (match) this.invalidEmail = false;
        else this.invalidEmail = true;
      },
      initialDatepicker() {
        if (this.$refs.datepicker) {
          $(this.$refs.datepicker)
            .datepicker({
              format: "yyyyÂπ¥mmÊúàddÊó•",
              autoclose: true,
              todayHighlight: true,
              forceParse: false,
              language: "ja",
            })
            .on("changeDate", ({ target }) => {
              let id = target.id;
              let value = target.value;
              this.form[id]["value"] = value;
            });
        }
      },
      getLocation() {
        let scope = this;
        // Check if the browser supports Geolocation
        return new Promise((resolve, reject) => {
          navigator.geolocation.getCurrentPosition(
            (position) => {
              var latitude = position.coords.latitude;
              var longitude = position.coords.longitude;

              // Display the location
              let setting_lat = !scope.settings.lat
                ? 0.0
                : parseFloat(scope.settings.lat);
              let setting_long = !scope.settings.long
                ? 0.0
                : parseFloat(scope.settings.long);
              if (!scope.settings.dimensionAllow) resolve(position);
              var distance = scope.haversineDistance(
                latitude,
                longitude,
                setting_lat,
                setting_long
              );
              if (Number(distance) > Number(scope.settings.dimensionAllow)) {
                reject("„ÅÇ„Å™„Åü„ÅÆÂ†¥ÊâÄ„ÅØË®±ÂèØ„Åï„Çå„Åü„Ç®„É™„Ç¢ÂÜÖ„Å´„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ");
              }
              resolve(position);
            },
            (error) => {
              // Handle errors, such as user denying location access
              console.log({ error });
              reject(
                "„Çµ„Éº„Éì„Çπ„ÇíÂà©Áî®„Åô„Çã„Å´„ÅØ„ÄÅ„Éá„Éê„Ç§„Çπ„ÅÆ‰ΩçÁΩÆÊÉÖÂ†±Ê©üËÉΩ„ÇíÊúâÂäπ„Å´„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ"
              );
            }
          );
        });
      },
      haversineDistance(lat1, lon1, lat2, lon2) {
        // Convert latitude and longitude from degrees to radians
        const toRadians = (angle) => (angle * Math.PI) / 180;
        const R = 6371; // Radius of the Earth in kilometers

        // Calculate differences between latitude and longitude
        const dLat = toRadians(lat2 - lat1);
        const dLon = toRadians(lon2 - lon1);

        // Haversine formula
        const a =
          Math.sin(dLat / 2) * Math.sin(dLat / 2) +
          Math.cos(toRadians(lat1)) *
            Math.cos(toRadians(lat2)) *
            Math.sin(dLon / 2) *
            Math.sin(dLon / 2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

        // Distance in kilometers
        const distance = R * c * 1000;

        return distance.toFixed(2);
      },
      getSegmentClass(index1) {
        if (index1 > this.quesVisit) {
          return "not-visited";
        } else {
          let currentQuestion = this.questions[index1];
          let formNow = this.form[`${index1 + 1}Ôºé${currentQuestion.question}`];
          if (formNow.criteria) {
            //ƒëa ti√™u ch√≠
            let check = true;
            for (const [critName, critValue] of Object.entries(
              formNow.criterias
            )) {
              if (critValue.value === "" || critValue.value.length === 0) {
                check = false;
              } else {
                check = true;
              }
            }
            if (!check) return "unanswered";
            if (check) return "answered";
          } else {
            //c√¢u th∆∞·ªùng
            if (formNow.value === "" || formNow.value.length === 0) {
              return "unanswered";
            } else {
              return "answered";
            }
          }
        }
      },
      isAnswered() {
        let scope = this;
        let storagesurveyID = localStorage.getItem(surveyID)
          ? JSON.parse(localStorage.getItem(surveyID))
          : null;
        let user = localStorage.getItem("user")
          ? JSON.parse(localStorage.getItem("user"))
          : null;
        if (!storagesurveyID && !user) return false;
        let now = new Intl.DateTimeFormat("ja-JP", {
          dateStyle: "long",
        }).format(new Date());
        if (storagesurveyID)
          scope.questionHandler(
            "„Åì„ÅÆÊäïÁ•®„Å´„ÅØÊó¢„Å´ÂõûÁ≠îÊ∏à„Åø„Åß„Åô„ÄÇ\nÂÜçÂ∫¶ÂõûÁ≠î„ÇíÈÄÅ‰ø°„Åó„Åæ„Åô„ÅãÔºü„ÄÄ"
          );
        return;
      },
      successHandler(msg) {
        document.getElementById("loading").style.display = "";
        Swal.fire({
          title: msg,
          icon: "success",
          timer: 1500,
          showConfirmButton: false,
        });

        setTimeout(() => {
          let scope = this;
          let form = scope.form;
          for (let [k, v] of Object.entries(scope.user)) {
            form[k] = { value: v };
          }
          sessionStorage.setItem(
            "vote_data",
            JSON.stringify({
              question: scope.questions,
              user: scope.user,
              response: form,
              vote: scope.vote,
              surveyID: surveyID,
            })
          );

          if (scope.vote.statistics === "Ë°®Á§∫") {
            this.statistic(scope.vote.id, scope.vote.dateRun);
          } else {
            let pageObject = {
              page: "thankyou",
            };
            let encodedPageParam = encodeURIComponent(
              JSON.stringify(pageObject)
            );
            let url = `https://myportal.sateraito.jp/gas?url=${this.url_top}?page=${encodedPageParam}`;
            window.open(url, "_self");
          }
        }, 1500);
      },
      statistic(surveyID, dateRun) {
        sessionStorage.setItem(
          "vote",
          JSON.stringify({ surveyID: surveyID, dateRun: dateRun })
        );
        let pageObject = {
          page: "statistic",
          code: surveyID,
          dateRun: dateRun,
        };
        let encodedPageParam = encodeURIComponent(JSON.stringify(pageObject));
        let url = `https://myportal.sateraito.jp/gas?url=${this.url_top}?page=${encodedPageParam}`;
        window.open(url, "_self");
      },
      failureHandler(error) {
        document.getElementById("loading").style.display = "none";

        let errorMessage = "‰∏çÊòé„Å™„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü"; // fallback message

        if (error) {
          if (typeof error === "string") {
            errorMessage = error;
          } else if (error.message) {
            errorMessage = error.message;
          } else if (typeof error === "object") {
            const str = JSON.stringify(error);
            errorMessage = str === "{}" ? errorMessage : str;
          }
        }

        Swal.fire({
          title: "„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü",
          text: errorMessage,
          icon: "error",
          confirmButtonColor: "#01932e",
          confirmButtonText: "Èñâ„Åò„Çã",
        }).then((result) => {});
      },
      questionHandler(msg) {
        Swal.fire({
          text: msg,
          icon: "question",
          showCancelButton: true,
          confirmButtonColor: "#01932e",
          cancelButtonColor: "#6A6A6A",
          confirmButtonText: "„ÅØ„ÅÑ",
          cancelButtonText: "„ÅÑ„ÅÑ„Åà",
          reverseButtons: true,
        }).then((result) => {
          if (result.isConfirmed) {
            this.disabledClick = false;
          } else {
            this.disabledClick = true;
          }
        });
      },
      previewForm() {
        let scope = this;
        let form = scope.form;
        if (scope.invalidEmail) return;

        for (let [k, v] of Object.entries(scope.user)) {
          form[k] = { value: v };
        }

        let validateState = this.validate(form);
        if (!validateState) {
          // Find and announce the first min/max violation (all-questions view)
          for (let i = 0; i < this.questions.length; i++) {
            const q = this.questions[i];
            const key = `${i + 1}Ôºé${q.question}`;
            const vstate = this.validates[key];
            if (vstate === "min") {
              Swal.fire({
                text: `Ë≥™Âïè${i + 1}„Åß„ÅØ„ÄÅÊúÄ‰Ωé${q.min || 0}ÂÄã„ÅÆÈÅ∏Êäû„ÅåÂøÖË¶Å„Åß„Åô„ÄÇ`,
                icon: "warning",
                confirmButtonColor: "#01932e",
                confirmButtonText: "Èñâ„Åò„Çã",
              });
              break;
            }
            if (vstate === "max") {
              Swal.fire({
                text: `Ë≥™Âïè${i + 1}„Åß„ÅØ„ÄÅÊúÄÂ§ß${q.max || 0}ÂÄã„Åæ„ÅßÈÅ∏Êäû„Åß„Åç„Åæ„Åô„ÄÇ`,
                icon: "warning",
                confirmButtonColor: "#01932e",
                confirmButtonText: "Èñâ„Åò„Çã",
              });
              break;
            }
          }
          return;
        }

        // sessionStorage.setItem('vote_data', JSON.stringify({ question: scope.questions, user: scope.user, response: form, vote: scope.vote, surveyID: surveyID }))
        // let pageObject = { page: "previewForm"};
        // let encodedPageParam = encodeURIComponent(JSON.stringify(pageObject));
        // let url = `https://myportal.sateraito.jp/gas?url=${scope.url_top}?page=${encodedPageParam}`;
        // window.open(url, '_blank')
        this.vote.displayType = "all";
        this.isPreview = true;
      },
      goBack() {
        this.isPreview = false;
        this.isBacked = true;
      },
      saveResponse() {
        let scope = this;
        let form = scope.form;

        Swal.fire({
          title: "ÈÄÅ‰ø°„Åó„Åæ„Åô„ÅãÔºü",
          icon: "question",
          showCancelButton: true,
          confirmButtonColor: "#01932e",
          cancelButtonColor: "#6A6A6A",
          cancelButtonText: "„ÅÑ„ÅÑ„Åà",
          confirmButtonText: "„ÅØ„ÅÑ",
          reverseButtons: true,
        }).then((result) => {
          if (result.isConfirmed) {
            let now = new Intl.DateTimeFormat("ja-JP", {
              dateStyle: "long",
              timeStyle: "medium",
            }).format(new Date());
            form["answer_created"] = { value: now, type: "date" };
            for (let [k, v] of Object.entries(scope.user)) {
              form[k] = { value: v };
            }
            document.getElementById("loading").style.display = "block";
            google.script.run
              .withSuccessHandler((res) => {
                if (!res) {
                  scope.failureHandler(res.msg);
                } else {
                  // scope.vote = res.data.vote;
                  // save storage user information
                  localStorage.setItem(
                    "user",
                    JSON.stringify({
                      ...scope.user,
                      answer_created: form["answer_created"].value,
                    })
                  );
                  localStorage.setItem(
                    surveyID,
                    JSON.stringify({ surveyID: surveyID })
                  );
                  scope.disabledClick = true;
                  scope.successHandler(res.msg);
                }
                document.getElementById("loading").style.display = "";
              })
              .saveResponse(form, surveyID);
          }
        });
      },
      getIPAddress() {
        let scope = this;
        let allowed_ip = scope.settings.allowed_ip;
        if (!allowed_ip || allowed_ip === "") return true;
        return new Promise((resolve, reject) => {
          fetch("https://api.ipify.org?format=json")
            .then((response) => response.json())
            .then((data) => {
              if (allowed_ip && !String(allowed_ip).includes(String(data.ip))) {
                reject("IP not allowed.");
                scope.disabledClick = true;
                scope.failureHandler(
                  "„Åì„ÅÆIP„Åã„Çâ„Ç¢„ÇØ„Çª„Çπ„ÅåÊãíÂê¶„Åï„Çå„Åæ„Åô„ÄÇÁÆ°ÁêÜËÄÖ„Å∏ÈÄ£Áµ°„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ"
                );
              } else {
                resolve(data.ip);
              }
            })
            .catch((error) => reject(error));
        });
      },
      prevQuestion() {
        if (this.currentQuestionIndex > 0) {
          this.currentQuestionIndex--;
        }
      },
      nextQuestion() {
        if (this.currentQuestionIndex < this.questions.length - 1) {
          let currentQuestion = this.questions[this.currentQuestionIndex];
          let key = `${this.currentQuestionIndex + 1}Ôºé${
            currentQuestion.question
          }`;
          let formNow = this.form[key];

          // reset validate m·∫∑c ƒë·ªãnh
          this.validates[key] = true;

          if (this.questions[this.currentQuestionIndex].question_required) {
            if (
              formNow &&
              formNow.criterias &&
              Object.keys(formNow.criterias).length > 0
            ) {
              // === ƒêA TI√äU CH√ç ===
              for (const [, critValue] of Object.entries(formNow.criterias)) {
                if (
                  critValue.value === "" ||
                  critValue.value == null ||
                  (Array.isArray(critValue.value) &&
                    critValue.value.length === 0)
                ) {
                  this.validates[key] = "empty";
                  break;
                }
              }
            } else {
              // === C√ÇU TH∆Ø·ªúNG ===
              const v = formNow ? formNow.value : null;
              if (
                v === "" ||
                v == null ||
                (Array.isArray(v) && v.length === 0)
              ) {
                this.validates[key] = "empty";
              }
            }
          }

          // Min/Max validation for multiSelect on next
          if (currentQuestion.question_type === "multiSelect") {
            const min = Number(currentQuestion.min ?? 0);
            const max = Number(currentQuestion.max ?? 0);

            if (
              formNow &&
              formNow.criterias &&
              Object.keys(formNow.criterias).length > 0
            ) {
              for (const [, critValue] of Object.entries(formNow.criterias)) {
                const arr = Array.isArray(critValue && critValue.value)
                  ? critValue.value
                  : [];
                if (min && arr.length < min) {
                  this.validates[key] = "min";
                  Swal.fire({
                    text: `Ë≥™Âïè${
                      this.currentQuestionIndex + 1
                    }„Åß„ÅØ„ÄÅÊúÄ‰Ωé${min}ÂÄã„ÅÆÈÅ∏Êäû„ÅåÂøÖË¶Å„Åß„Åô„ÄÇ`,
                    icon: "warning",
                    confirmButtonColor: "#01932e",
                    confirmButtonText: "Èñâ„Åò„Çã",
                  });
                  break;
                }
                if (max && arr.length > max) {
                  this.validates[key] = "max";
                  Swal.fire({
                    text: `Ë≥™Âïè${
                      this.currentQuestionIndex + 1
                    }„Åß„ÅØ„ÄÅÊúÄÂ§ß${max}ÂÄã„Åæ„ÅßÈÅ∏Êäû„Åß„Åç„Åæ„Åô„ÄÇ`,
                    icon: "warning",
                    confirmButtonColor: "#01932e",
                    confirmButtonText: "Èñâ„Åò„Çã",
                  });
                  break;
                }
              }
            } else {
              const arr = Array.isArray(formNow && formNow.value)
                ? formNow.value
                : [];
              if (min && arr.length < min) {
                this.validates[key] = "min";
                Swal.fire({
                  text: `Ë≥™Âïè${
                    this.currentQuestionIndex + 1
                  }„Åß„ÅØ„ÄÅÊúÄ‰Ωé${min}ÂÄã„ÅÆÈÅ∏Êäû„ÅåÂøÖË¶Å„Åß„Åô„ÄÇ`,
                  icon: "warning",
                  confirmButtonColor: "#01932e",
                  confirmButtonText: "Èñâ„Åò„Çã",
                });
              } else if (max && arr.length > max) {
                this.validates[key] = "max";
                Swal.fire({
                  text: `Ë≥™Âïè${
                    this.currentQuestionIndex + 1
                  }„Åß„ÅØ„ÄÅÊúÄÂ§ß${max}ÂÄã„Åæ„ÅßÈÅ∏Êäû„Åß„Åç„Åæ„Åô„ÄÇ`,
                  icon: "warning",
                  confirmButtonColor: "#01932e",
                  confirmButtonText: "Èñâ„Åò„Çã",
                });
              }
            }
          }

          // N·∫øu validate pass ‚Üí next
          if (this.validates[key] === true) {
            this.currentQuestionIndex++;
            if (this.quesVisit < this.currentQuestionIndex) {
              this.quesVisit = this.currentQuestionIndex;
            }
          }
        }
      },
      activateInput(index, idex, idx) {
        let inputId = `Q${index + 1}-C${idex + 1}-${idx + 1}`;
        let input = document.getElementById(inputId);
        if (input.type === "radio") {
          input.click();
        } else if (input.type === "checkbox") {
          // N·∫øu l√† checkbox, kh√¥ng l√†m g√¨ c·∫£, ƒë·ªÉ n√≥ ch·ªâ c√≥ th·ªÉ ƒë∆∞·ª£c k√≠ch ho·∫°t qua h√†m activateInput
        }
      },
      showPassword() {
        this.isShowPW = !this.isShowPW;
      },
      updateElementHeights() {
        const spanElement = document.querySelector(
          ".background-top-oneQuest span"
        );
        const pElement = document.querySelector(".background-top-oneQuest p");
        const backgroundTopElement = document.querySelector(
          ".background-top-oneQuest"
        );
        const formSlideElement = document.querySelector(".form-slide");
        const backgroundBottomElement = document.querySelector(
          ".background-bottom-oneQuest"
        );

        if (
          spanElement &&
          pElement &&
          backgroundTopElement &&
          formSlideElement &&
          backgroundBottomElement
        ) {
          const spanHeight = spanElement.offsetHeight;
          const pHeight = pElement.offsetHeight;
          const totalHeight = spanHeight + pHeight + 20;
          backgroundTopElement.style.height = totalHeight + 20 + "px";
          formSlideElement.style.top = totalHeight + "px";
          backgroundBottomElement.style.top = totalHeight + 20 + "px";
        }
      },
    },
  });
  app.mount("#app");
</script>
